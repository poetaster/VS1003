/*
  from vs1003_hello & and the mozzi examples

  A simple MP3 flow player to test if board and library are working together.
  The following sketch should say "Hello" every 0.5s :)
  Created 2012-04-05 by Andrey Karpov
*/


#include <SPI.h>

//#include "vs10xx_uc.h" // From VLSI website: http://www.vlsi.fi/en/support/software/microcontrollersoftware.html */
//#include "dac1003b.h"

// SCI Register
const uint8_t SCI_MODE = 0x0;
const uint8_t SCI_STATUS = 0x1;
const uint8_t SCI_BASS = 0x2;
const uint8_t SCI_CLOCKF = 0x3;
const uint8_t SCI_DECODE_TIME = 0x4;        // current decoded time in full seconds
const uint8_t SCI_AUDATA = 0x5;
const uint8_t SCI_WRAM = 0x6;
const uint8_t SCI_WRAMADDR = 0x7;
const uint8_t SCI_AIADDR = 0xA;
const uint8_t SCI_VOL = 0xB;
const uint8_t SCI_AICTRL0 = 0xC;
const uint8_t SCI_AICTRL1 = 0xD;
const uint8_t SCI_AICTRL2 = 0xE;
const uint8_t SCI_AICTRL3 = 0xF;
const uint8_t SCI_num_registers = 0xF;
// Stream header data
const uint8_t SCI_HDAT0 = 0x8;          // Stream header data 0
const uint8_t SCI_HDAT1 = 0x9;          // Stream header data 1

// SCI_MODE bits
const uint8_t SM_SDINEW = 11;           // Bitnumber in SCI_MODE always on
const uint8_t SM_RESET = 2;             // Bitnumber in SCI_MODE soft reset
const uint8_t SM_CANCEL = 3;            // Bitnumber in SCI_MODE cancel song
const uint8_t SM_TESTS = 5;             // Bitnumber in SCI_MODE for tests
const uint8_t SM_LINE1 = 14;            // Bitnumber in SCI_MODE for Line input
const uint8_t SM_STREAM = 6;            // Bitnumber in SCI_MODE for Streaming Mode
const uint8_t SM_ADPCM = 12;            // Bitnumber in SCI_MODE for PCM/ADPCM recording active

const uint16_t ADDR_REG_GPIO_DDR_RW = 0xc017;
const uint16_t ADDR_REG_GPIO_VAL_R = 0xc018;
const uint16_t ADDR_REG_GPIO_ODATA_RW = 0xc019;
const uint16_t ADDR_REG_I2S_CONFIG_RW = 0xc040;

// Timer settings  for VS1053 and VS1063 */
const uint16_t INT_ENABLE = 0xC01A;
const uint16_t SC_MULT_53_35X = 0x8000;
const uint16_t SC_ADD_53_10X = 0x0800;

const uint16_t SC_EAR_SPEAKER_LO = 0x0010;
const uint16_t SC_EAR_SPEAKER_HI = 0x0080;
const uint16_t SS_SWING_BITS  =   3;

const uint16_t  SS_SWING_MASK   =  0x7000;
const uint16_t  SS_VER_BITS     =   4;
const uint16_t  SS_VER_MASK     =   0x00f0;
const uint16_t  SS_AVOL_BITS    =   2;
const uint16_t  SS_AVOL_MASK    =   0x0003;
const uint16_t  SS_VER_VS1053 = 0x40;
const uint16_t  SS_VER_VS1003 = 0x30;

// VS1053 Shield pin definitions
#define VS_XCS    9 // Control Chip Select Pin (for accessing SPI Control/Status registers)
#define VS_XDCS   6 // Data Chip Select / BSYNC Pin
#define VS_DREQ   7 // Data Request Pin: Player asks for more data
#define VS_RESET  8 // Reset is active low


// VS10xx SPI pin connections (both boards)
// Provided here for info only - not used in the sketch as the SPI library handles this
#define VS_MOSI   11
#define VS_MISO   12
#define VS_SCK    13
#define VS_SS     10

#define CONTROL_RATE 256 // Hz, powers of 2 are most reliable

#define TEST 1
//#define SINTEST 1

#ifdef TEST
char teststr[32];
#endif

unsigned char HelloMP3[] = {
  0xFF, 0xF2, 0x40, 0xC0, 0x19, 0xB7, 0x00, 0x14, 0x02, 0xE6, 0x5C, /* ..@.......\ */
  0x01, 0x92, 0x68, 0x01, 0xF1, 0x5E, 0x03, 0x08, 0xF0, 0x24, 0x80, /* ..h..^...$. */
  0x05, 0x9E, 0x20, 0xC6, 0xFC, 0x12, 0x32, 0x5C, 0xBF, 0xF9, 0xB9, /* .. ...2\... */
  0x20, 0x4A, 0x7F, 0x85, 0xEC, 0x4C, 0xCD, 0xC7, 0x27, 0xFE, 0x5C, /*  J...L..'.\ */
  0x34, 0x25, 0xCB, 0xE6, 0xFF, 0xFF, 0x8E, 0x42, 0xE1, 0xA0, 0x5E, /* 4%.....B..^ */
  0xCA, 0x6E, 0x30, 0x9F, 0xFF, 0xF8, 0xC2, 0x12, 0x84, 0xB9, 0x7C, /* .n0.......| */
  0xDC, 0x61, 0x09, 0x4A, 0x7F, 0xFF, 0xFF, 0xF9, 0x7D, 0x32, 0x51, /* .a.J....}2Q */
  0x09, 0x7C, 0xE1, 0xA5, 0x6E, 0xB4, 0xFF, 0xFF, 0xFF, 0xFF, 0xD3, /* .|..n...... */
  0x34, 0x41, 0x91, 0xF0, 0x11, 0x8F, 0x00, 0x0F, 0x81, 0x9C, 0x10, /* 4A......... */
  0xEE, 0x59, 0xCE, 0x56, 0x67, 0xFF, 0xF2, 0x42, 0xC0, 0xEC, 0x53, /* .Y.Vg..B..S */
  0x09, 0x15, 0xF9, 0xAA, 0xA8, 0x0D, 0xD9, 0x40, 0x00, 0xCA, 0x34, /* .......@..4 */
  0x53, 0xD9, 0x18, 0xAB, 0x7D, 0xF7, 0x89, 0x3F, 0x11, 0x38, 0x94, /* S...}..?.8. */
  0x82, 0x59, 0x93, 0x20, 0x6A, 0x0C, 0xEE, 0x8E, 0x58, 0xFA, 0x38, /* .Y. j...X.8 */
  0x82, 0xCA, 0xF0, 0x58, 0xBB, 0xDA, 0x0C, 0x50, 0x56, 0x1F, 0xBB, /* ...X...PV.. */
  0x18, 0x5D, 0x8B, 0x9F, 0xDA, 0x71, 0x4F, 0xFF, 0xBD, 0xFE, 0xEF, /* .]...qO.... */
  0x69, 0x36, 0x86, 0x3C, 0x50, 0xBB, 0x0A, 0x07, 0x89, 0x54, 0xF0, /* i6.<P....T. */
  0x88, 0x9F, 0x90, 0x95, 0x30, 0x94, 0x2E, 0x7E, 0xF0, 0x64, 0x96, /* ....0..~.d. */
  0x79, 0x08, 0x3E, 0x20, 0x97, 0x28, 0x34, 0x9C, 0x09, 0x7F, 0xD2, /* y.> .(4.... */
  0xC0, 0x01, 0x75, 0xF8, 0x05, 0x6B, 0x5F, 0x41, 0x17, 0x0B, 0xE7, /* ..u..k_A... */
  0xFF, 0xF2, 0x40, 0xC0, 0x61, 0xE5, 0x0B, 0x16, 0x09, 0xC6, 0xC5, /* ..@.a...... */
  0x74, 0x7B, 0xCC, 0x94, 0x7A, 0xF7, 0x80, 0x76, 0xB2, 0xD2, 0xF8, /* t{..z..v... */
  0x39, 0x06, 0x38, 0xFD, 0x71, 0xC5, 0xDE, 0x3A, 0x38, 0xBF, 0xD5, /* 9.8.q..:8.. */
  0xF7, 0x12, 0x37, 0xCB, 0xF5, 0x63, 0x0C, 0x9B, 0xCE, 0x77, 0x25, /* ..7..c...w% */
  0xED, 0xFB, 0x3D, 0x6B, 0x35, 0xF9, 0x6D, 0xD7, 0xF9, 0x2C, 0xD1, /* ..=k5.m..,. */
  0x97, 0x15, 0x87, 0x93, 0xA4, 0x49, 0x4A, 0x18, 0x16, 0x07, 0xA1, /* .....IJ.... */
  0x60, 0xF7, 0x52, 0x94, 0xDB, 0x02, 0x16, 0x70, 0xB2, 0xD8, 0x80, /* `.R....p... */
  0x30, 0xC2, 0x94, 0x40, 0x81, 0x74, 0x5A, 0x19, 0x7A, 0x80, 0x60, /* 0..@.tZ.z.` */
  0x41, 0x21, 0x46, 0x95, 0xD5, 0xC4, 0x40, 0xD2, 0x01, 0xC0, 0x01, /* A!F...@.... */
  0xDA, 0xD9, 0xA0, 0xB1, 0x01, 0xFF, 0xF2, 0x42, 0xC0, 0x82, 0x10, /* .......B... */
  0x0B, 0x12, 0xF9, 0x9E, 0xC9, 0x7E, 0x7A, 0xC6, 0x95, 0x55, 0x09, /* .....~z..U. */
  0x8B, 0x19, 0x5E, 0x8B, 0x26, 0xCA, 0xEB, 0x68, 0x8A, 0x05, 0x8F, /* ..^.&..h... */
  0x36, 0xA5, 0xA5, 0x03, 0xB8, 0x9C, 0xED, 0x24, 0x51, 0x59, 0x90, /* 6......$QY. */
  0xF6, 0xC5, 0x7D, 0xB5, 0xAD, 0xAF, 0xF6, 0x3B, 0x18, 0xEF, 0x3F, /* ..}....;..? */
  0xFF, 0xFF, 0x4E, 0xDE, 0x16, 0x66, 0x0B, 0xAA, 0x33, 0x23, 0xDD, /* ..N..f..3#. */
  0x9C, 0x4E, 0x6E, 0x55, 0x22, 0x9D, 0xA2, 0x40, 0xA6, 0x36, 0x31, /* .NnU"..@.61 */
  0x69, 0xA5, 0xE1, 0xD9, 0x7F, 0xF7, 0xC6, 0xCC, 0x48, 0x00, 0x0E, /* i.......H.. */
  0x90, 0x16, 0x00, 0x0F, 0xDE, 0x6E, 0x80, 0x11, 0x0C, 0x9A, 0x4F, /* .....n....O */
  0x56, 0xDB, 0x88, 0xD3, 0xB2, 0x1C, 0x00, 0xE0, 0x2E, 0x3E, 0xAC, /* V........>. */
  0xFF, 0xF2, 0x40, 0xC0, 0x1C, 0xE5, 0x19, 0x13, 0x31, 0x4E, 0xCD, /* ..@.....1N. */
  0x9E, 0xC3, 0x06, 0x71, 0x03, 0x85, 0xE5, 0xB5, 0x6D, 0x88, 0x50, /* ...q....m.P */
  0x8E, 0x0E, 0x17, 0x3B, 0x19, 0xFB, 0x4E, 0x3B, 0x99, 0xEF, 0x4C, /* ...;..N;..L */
  0x9E, 0xF7, 0x7B, 0x31, 0x7C, 0x3C, 0x5F, 0xFF, 0xF4, 0xF8, 0xE3, /* ..{1|<_.... */
  0x92, 0x42, 0x07, 0x8E, 0x83, 0x8E, 0x0F, 0x05, 0x08, 0x91, 0xA3, /* .B......... */
  0x16, 0xE2, 0xDF, 0xB7, 0x62, 0x60, 0x48, 0x31, 0x3C, 0xFF, 0xD4, /* ....b`H1<.. */
  0x9E, 0x0C, 0x68, 0x00, 0x77, 0x54, 0xE3, 0x1E, 0x05, 0xC5, 0xF8, /* ..h.wT..... */
  0xEA, 0x8D, 0x82, 0x9D, 0x08, 0xA9, 0x06, 0x8D, 0x1E, 0x5D, 0x7C, /* .........]| */
  0x7F, 0x08, 0xC0, 0x50, 0x45, 0x42, 0xD0, 0x36, 0xF8, 0xB2, 0x4D, /* ...PEB.6..M */
  0x53, 0x0C, 0x80, 0x3B, 0x4D, 0xFF, 0xF2, 0x42, 0xC0, 0x2F, 0x3C, /* S..;M..B./< */
  0x25, 0x19, 0x29, 0xFE, 0xBC, 0x2E, 0xC4, 0xD0, 0x99, 0x4C, 0x48, /* %.)......LH */
  0xB0, 0x9C, 0x49, 0xD2, 0x1A, 0x2D, 0x02, 0xC2, 0x79, 0x69, 0x16, /* ..I..-..yi. */
  0x92, 0xA8, 0xC5, 0xAB, 0x45, 0x5A, 0x68, 0xE8, 0x75, 0x57, 0xCD, /* ....EZh.uW. */
  0xF1, 0xB9, 0xAA, 0x13, 0x88, 0xE4, 0x87, 0x42, 0x15, 0xB3, 0x58, /* .......B..X */
  0xF5, 0xA3, 0x46, 0xB1, 0xCF, 0xD3, 0x59, 0x7E, 0xBA, 0xB5, 0xA7, /* ..F...Y~... */
  0x6B, 0x0B, 0x17, 0x57, 0x6B, 0x5C, 0x4A, 0xCD, 0x53, 0x76, 0x2A, /* k..Wk\J.Sv* */
  0x1D, 0x28, 0xC5, 0x1C, 0x76, 0x5C, 0xDD, 0x0A, 0x00, 0x4B, 0xC0, /* .(..v\...K. */
  0x1B, 0xCA, 0xA8, 0xE9, 0x81, 0x5B, 0xA6, 0xDC, 0xA4, 0x59, 0x13, /* .....[...Y. */
  0xFC, 0xBA, 0x8F, 0x98, 0x79, 0x44, 0x25, 0xC9, 0x35, 0x38, 0xCA, /* ....yD%.58. */
  0xFF, 0xF2, 0x40, 0xC0, 0xB9, 0x7D, 0x1A, 0x13, 0x79, 0x6A, 0xC8, /* ..@..}..yj. */
  0x3E, 0xC4, 0x46, 0x94, 0x8D, 0x3C, 0x67, 0x85, 0xB1, 0xA8, 0x89, /* >.F..<g.... */
  0xC0, 0xF2, 0xE6, 0x2F, 0x9D, 0x7C, 0xC9, 0xB4, 0xBE, 0xCF, 0xE1, /* .../.|..... */
  0x7D, 0xFE, 0x1F, 0x03, 0x00, 0x12, 0x84, 0x72, 0x8C, 0xE7, 0xD8, /* }......r... */
  0x5E, 0xC9, 0xA9, 0x01, 0xBA, 0x9B, 0xC4, 0x10, 0x5C, 0x70, 0x2E, /* ^.......\p. */
  0x6C, 0x48, 0xE7, 0x8C, 0x15, 0x0B, 0x06, 0x01, 0xE5, 0xFF, 0xFF, /* lH......... */
  0xD4, 0x0D, 0x00, 0x0F, 0xCE, 0x58, 0x95, 0x61, 0xA8, 0x9E, 0x7B, /* .....X.a..{ */
  0x19, 0x98, 0xB0, 0xF0, 0xC6, 0x72, 0x82, 0xD5, 0x27, 0x06, 0x47, /* .....r..'.G */
  0x41, 0x22, 0x0F, 0x65, 0x93, 0xC9, 0x8A, 0x09, 0x19, 0x48, 0x1B, /* A".e.....H. */
  0xBD, 0xD6, 0x64, 0x1A, 0xAC, 0xFF, 0xF2, 0x42, 0xC0, 0xF1, 0x11, /* ..d....B... */
  0x25, 0x14, 0x22, 0x06, 0xBC, 0x0E, 0xD4, 0x4E, 0x99, 0x90, 0xA8, /* %."....N... */
  0xD8, 0xB7, 0xAD, 0x5D, 0x3E, 0xAF, 0x6E, 0xBE, 0x66, 0x83, 0xA4, /* ...]>.n.f.. */
  0xE3, 0xC2, 0xE0, 0x29, 0x43, 0x87, 0x5F, 0x4F, 0x27, 0x9C, 0x2C, /* ...)C._O'., */
  0xD0, 0x91, 0xF3, 0x87, 0x9B, 0x54, 0xED, 0xD1, 0xB4, 0xF3, 0x39, /* .....T....9 */
  0x87, 0x22, 0x06, 0x86, 0x0D, 0x71, 0xE4, 0x6F, 0x2A, 0x08, 0x04, /* ."...q.o*.. */
  0xC0, 0x03, 0x2A, 0xB1, 0xE2, 0x05, 0x4D, 0x64, 0xA1, 0x9C, 0xA6, /* ..*...Md... */
  0x0D, 0x41, 0xA6, 0xF2, 0x7A, 0xC1, 0x30, 0xC3, 0x38, 0x26, 0x09, /* .A..z.0.8&. */
  0x50, 0x08, 0xC4, 0xF6, 0x30, 0x0C, 0xA6, 0xA9, 0x17, 0x00, 0x13, /* P...0...... */
  0x0C, 0xDC, 0xC4, 0x2F, 0x28, 0xEB, 0x3F, 0xCD, 0x7A, 0x3D, 0x2F, /* .../(.?.z=/ */
  0xFF, 0xF2, 0x40, 0xC0, 0x18, 0x6F, 0x2E, 0x13, 0xA1, 0xF2, 0xBC, /* ..@..o..... */
  0x36, 0xCB, 0x4E, 0x99, 0x6E, 0xFC, 0xEE, 0xC5, 0xF0, 0xA0, 0xB7, /* 6.N.n...... */
  0x92, 0xD4, 0xEE, 0x79, 0x7C, 0x50, 0x5D, 0xE5, 0x04, 0x94, 0xA9, /* ...y|P].... */
  0x76, 0xCF, 0x6C, 0x70, 0xDD, 0x0D, 0xD4, 0xEE, 0xED, 0x98, 0xE8, /* v.lp....... */
  0xC8, 0x35, 0x36, 0x7A, 0x0C, 0x05, 0x80, 0x03, 0xBC, 0xBE, 0x91, /* .56z....... */
  0x00, 0x7C, 0xAE, 0x65, 0xB8, 0x91, 0xA3, 0x33, 0xBA, 0x68, 0x60, /* .|.e...3.h` */
  0xD4, 0x1A, 0x66, 0xF8, 0x43, 0xA0, 0x20, 0x89, 0xE7, 0x80, 0xD8, /* ..f.C. .... */
  0x1E, 0x4F, 0xA0, 0x04, 0x60, 0x06, 0x0A, 0xA4, 0x91, 0x24, 0xFA, /* .O..`....$. */
  0x9F, 0x57, 0x53, 0xF4, 0x7A, 0xDB, 0x5F, 0x56, 0xE3, 0x6E, 0x0B, /* .WS.z._V.n. */
  0x8B, 0x3A, 0x1C, 0xF9, 0x5E, 0xFF, 0xF2, 0x42, 0xC0, 0xB1, 0x00, /* .:..^..B... */
  0x38, 0x14, 0x09, 0xEE, 0xB4, 0x36, 0xD3, 0x4E, 0x99, 0xA4, 0x78, /* 8....6.N..x */
  0x94, 0x73, 0xC4, 0x66, 0x30, 0xF5, 0xEA, 0xDB, 0xBA, 0x67, 0x67, /* .s.f0....gg */
  0x95, 0x6B, 0xAB, 0x68, 0x5D, 0x08, 0xA1, 0x39, 0x56, 0xAB, 0x1E, /* .k.h]..9V.. */
  0xD5, 0x03, 0xE8, 0x01, 0x70, 0x00, 0xB3, 0x93, 0x33, 0x19, 0x8C, /* ....p...3.. */
  0x61, 0x8F, 0xBB, 0x5D, 0x24, 0x12, 0x63, 0xD3, 0x4B, 0x5D, 0x91, /* a..]$.c.K]. */
  0x08, 0x43, 0x22, 0x56, 0x1A, 0xC5, 0x10, 0x21, 0x84, 0xA8, 0xEA, /* .C"V...!... */
  0x80, 0xBF, 0x16, 0x8E, 0x3D, 0x46, 0x18, 0x9C, 0x6E, 0x9A, 0x91, /* ....=F..n.. */
  0xE6, 0xC9, 0x6F, 0xD2, 0x7D, 0x27, 0xD7, 0xE9, 0x6B, 0xFF, 0x0A, /* ..o.}'..k.. */
  0x03, 0x43, 0x89, 0xD5, 0xBF, 0x52, 0x97, 0x0A, 0x25, 0x95, 0x0D, /* .C...R..%.. */
  0xFF, 0xF2, 0x40, 0xC0, 0xF5, 0xC3, 0x41, 0x13, 0x81, 0xEE, 0xA8, /* ..@...A.... */
  0x5E, 0xD3, 0x44, 0x98, 0xFC, 0xCF, 0x97, 0xF9, 0x58, 0xB5, 0x33, /* ^.D.....X.3 */
  0xB1, 0x85, 0x47, 0x86, 0xD7, 0x98, 0x01, 0x3B, 0xA3, 0x4F, 0x7E, /* ..G....;.O~ */
  0x04, 0xA6, 0xC3, 0x39, 0x21, 0x70, 0x27, 0x62, 0xB5, 0x18, 0x10, /* ...9!p'b... */
  0x09, 0x99, 0x00, 0x8B, 0x7E, 0xF2, 0xBF, 0x52, 0x18, 0x26, 0x30, /* ....~..R.&0 */
  0x1C, 0xB0, 0x01, 0x49, 0x30, 0xE0, 0xC3, 0x11, 0x46, 0x05, 0xCC, /* ...I0...F.. */
  0x49, 0x14, 0x28, 0xB2, 0xED, 0x4B, 0x57, 0x5A, 0x2F, 0xB7, 0x46, /* I.(..KWZ/.F */
  0x63, 0x34, 0xD2, 0xDA, 0x9F, 0x56, 0x32, 0xB7, 0xA2, 0x25, 0xFF, /* c4...V2..%. */
  0x94, 0x28, 0x33, 0x7F, 0x3B, 0xC4, 0x50, 0xEC, 0xB1, 0xE2, 0x26, /* .(3.;.P...& */
  0xA1, 0xB7, 0x07, 0x7F, 0xFB, 0xFF, 0xF2, 0x42, 0xC0, 0x67, 0x6A, /* .......B.gj */
  0x4C, 0x13, 0xF9, 0x6A, 0x90, 0x7E, 0xDB, 0x44, 0x94, 0x3F, 0xFF, /* L..j.~.D.?. */
  0x14, 0xD6, 0x2A, 0xFF, 0xFF, 0xC1, 0x34, 0x8C, 0x48, 0x22, 0x00, /* ..*...4.H". */
  0x06, 0x8F, 0x21, 0xFD, 0x64, 0x60, 0x04, 0x92, 0x42, 0xEA, 0x74, /* ..!.d`..B.t */
  0x32, 0x37, 0xAA, 0x5A, 0x9F, 0x67, 0x01, 0x8B, 0x3F, 0x37, 0x31, /* 27.Z.g..?71 */
  0xDD, 0x06, 0x3C, 0x01, 0x34, 0x30, 0xE0, 0x5C, 0x78, 0x78, 0xCB, /* ..<.40.\xx. */
  0xD6, 0xF1, 0x31, 0x8A, 0x69, 0x61, 0x93, 0x92, 0x42, 0xCE, 0x4B, /* ..1.ia..B.K */
  0xC5, 0x02, 0x4E, 0x73, 0xC6, 0x24, 0x30, 0xCD, 0x08, 0x66, 0xC6, /* ..Ns.$0..f. */
  0x35, 0xAB, 0xA2, 0x3D, 0x2F, 0xB3, 0xBD, 0x34, 0x87, 0x13, 0xEE, /* 5..=/..4... */
  0x71, 0x45, 0x68, 0xFA, 0xEA, 0x05, 0x84, 0x41, 0x36, 0x4C, 0x9A, /* qEh....A6L. */
  0xFF, 0xF2, 0x40, 0xC0, 0xC9, 0x92, 0x56, 0x13, 0xD0, 0x6E, 0x70, /* ..@...V..np */
  0x54, 0xD3, 0xCC, 0x28, 0x06, 0xD7, 0x0E, 0xA4, 0x1D, 0x9C, 0x9D, /* T..(....... */
  0xD9, 0xA9, 0x88, 0x7B, 0xB5, 0xA3, 0x56, 0xB7, 0x4B, 0x4B, 0x5A, /* ...{..V.KKZ */
  0x9B, 0x2C, 0xA9, 0xAD, 0x6F, 0x99, 0x6C, 0xC0, 0x4C, 0x14, 0x14, /* .,..o.l.L.. */
  0xEF, 0xB4, 0x20, 0x91, 0x5F, 0xBC, 0x81, 0x41, 0x41, 0x5D, 0xD4, /* .. ._..AA]. */
  0x20, 0xBD, 0x05, 0x1A, 0x6F, 0xE2, 0x68, 0x56, 0x41, 0x41, 0x57, /*  ...o.hVAAW */
  0xF9, 0xBF, 0x89, 0x82, 0x8E, 0xC7, 0x8F, 0x0A, 0x0A, 0x09, 0x37, /* ..........7 */
  0xF1, 0x05, 0x0A, 0x0A, 0x0A, 0x0A, 0x09, 0x05, 0x37, 0xFF, 0x10, /* ........7.. */
  0x50, 0x50, 0x53, 0x65, 0xFF, 0xFF, 0xFD, 0x75, 0xDF, 0xFF, 0xFF, /* PPSe...u... */
  0x68, 0x4F, 0xFF, 0x84, 0x70, 0xFF, 0xF2, 0x42, 0xC0, 0x27, 0x50, /* hO..p..B.'P */
  0x5F, 0x17, 0xE8, 0x82, 0x3C, 0x11, 0x58, 0x18, 0x01, 0x55, 0x48, /* _...<.X..UH */
  0xBC, 0x52, 0xFC, 0x4A, 0x4C, 0x3C, 0xD5, 0xF6, 0x11, 0x2D, 0xBF, /* .R.JL<...-. */
  0xEA, 0x03, 0x5C, 0x57, 0x29, 0xBF, 0xC3, 0x75, 0x1C, 0xE6, 0xDD, /* ..\W)..u... */
  0xBF, 0xED, 0xEF, 0xD0, 0x98, 0x77, 0x71, 0x95, 0x73, 0xFF, 0xED, /* .....wq.s.. */
  0x54, 0xBE, 0xD5, 0xEE, 0xAE, 0xC2, 0xD5, 0x0B, 0xFF, 0xF1, 0x97, /* T.......... */
  0x8A, 0xE4, 0x42, 0x09, 0x99, 0xB1, 0xEA, 0x94, 0xDC, 0x78, 0xB5, /* ..B......x. */
  0x34, 0x0F, 0xF1, 0x8F, 0xFC, 0x15, 0xF6, 0xFA, 0xB1, 0x47, 0xA9, /* 4........G. */
  0x6C, 0x67, 0x43, 0x8B, 0xF2, 0x76, 0x22, 0xED, 0xDA, 0x85, 0xBA, /* lgC..v".... */
  0x2F, 0xC7, 0xF9, 0xCF, 0xFC, 0xDB, 0x46, 0x2E, 0x50, 0x0A, 0x84, /* /.....F.P.. */
  0xFF, 0xF2, 0x40, 0xC0, 0xC6, 0x4A, 0x59, 0x28, 0x2B, 0x19, 0xE0, /* ..@..JY(+.. */
  0x01, 0x89, 0x78, 0x00, 0x52, 0x85, 0x3C, 0x8E, 0x54, 0x9A, 0x48, /* ..x.R.<.T.H */
  0x5A, 0x72, 0x32, 0x94, 0xBF, 0x43, 0x4F, 0x24, 0x53, 0x4B, 0xEC, /* Zr2..CO$SK. */
  0x4B, 0x99, 0x0E, 0x66, 0x1F, 0xFF, 0xCE, 0x7F, 0xFF, 0x3F, 0x10, /* K..f.....?. */
  0xAE, 0x82, 0x62, 0x71, 0x34, 0x18, 0x59, 0x9B, 0x51, 0xC7, 0x59, /* ..bq4.Y.Q.Y */
  0xCE, 0xEE, 0xA5, 0xFE, 0x02, 0xBB, 0x30, 0x91, 0x49, 0xD5, 0x4B, /* ......0.I.K */
  0xF3, 0xDC, 0x9A, 0xA9, 0x57, 0x8E, 0x72, 0x10, 0xC0, 0x5D, 0x60, /* ....W.r..]` */
  0x67, 0xFC, 0x7D, 0xD6, 0xBA, 0xDD, 0xB3, 0x8B, 0x5A, 0x0A, 0x4C, /* g.}.....Z.L */
  0x41, 0x4D, 0x45, 0x33, 0x2E, 0x39, 0x33, 0xAA, 0xAA, 0xAA, 0xAA, /* AME3.93.... */
  0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x54, 0x41, 0x47, 0x48, 0x65, 0x6C, /* .....TAGHel */
  0x6C, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, /* lo          */
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, /*             */
  0x20, 0x20, 0x20, 0x20, 0x20, 0x50, 0x61, 0x6E, 0x75, 0x2D, 0x4B, /*      Panu-K */
  0x72, 0x69, 0x73, 0x74, 0x69, 0x61, 0x6E, 0x20, 0x50, 0x6F, 0x69, /* ristian Poi */
  0x6B, 0x73, 0x61, 0x6C, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, /* ksalo       */
  0x20, 0x20, 0x56, 0x53, 0x44, 0x53, 0x50, 0x20, 0x54, 0x65, 0x73, /*   VSDSP Tes */
  0x74, 0x69, 0x6E, 0x67, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, /* ting        */
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, /*             */
  0x20, 0x20, 0x20, 0x4D, 0x50, 0x33, 0x20, 0x48, 0x65, 0x6C, 0x6C, /*    MP3 Hell */
  0x6F, 0x2C, 0x20, 0x57, 0x6F, 0x72, 0x6C, 0x64, 0x21, 0x20, 0x20, /* o, World!   */
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, /*             */
  0x00, /* . */
};
void setup() {

  // initiate a serial port at 57600
  Serial.begin(9600);
  Serial.println("hello");
  initialiseVS10xx();



  /*
    aCos1.setFreq(440.f);
    aCos2.setFreq(220.f);
    kEnv1.setFreq(0.25f);
    kEnv2.setFreq(0.30f);
    startMozzi(CONTROL_RATE);*/

}

bool driverReady = 0;

void playSound() {

  if (driverReady) {
    size_t len = sizeof(HelloMP3);
    uint8_t*data = HelloMP3;
    
    
    send_buffer(HelloMP3, sizeof(HelloMP3));
  }

}

void loop() {

  Serial.println("loop");
  
  VSStatus();
  delay(1000);
  //playSound();
  //send_buffer(HelloMP3, sizeof(HelloMP3));
  delay(1000);
}

/***********************************************************************************************

   Code from here on is the magic required to initialise the VS10xx and
   put it into real-time MIDI mode using an SPI-delivered patch.

   Here be dragons...

   Based on VS1003b/VS1033c/VS1053b Real-Time MIDI Input Application
   http://www.vlsi.fi/en/support/software/vs10xxapplications.html

   With some input from MP3_Shield_RealtimeMIDI.ino by Matthias Neeracher
   which was based on Nathan Seidle's Sparkfun Electronics example code for the Sparkfun
   MP3 Player and Music Instrument shields and and VS1053 breakout board.

 ***********************************************************************************************
*/

void initialiseVS10xx () {
  // Set up the pins controller the SPI link to the VS1053
  pinMode(VS_DREQ, INPUT);
  pinMode(VS_XCS, OUTPUT);
  pinMode(VS_XDCS, OUTPUT);
  pinMode(VS_RESET, OUTPUT);

  // Setup SPI
  // The Arduino's Slave Select pin is only required if the
  // Arduino is acting as an SPI slave device.
  // However, the internal circuitry for the ATmeta328 says
  // that if the SS pin is low, the MOSI/MISO lines are disabled.
  // This means that when acting as an SPI master (as in this case)
  // the SS pin must be set to an OUTPUT to prevent the SPI lines
  // being automatically disabled in hardware.
  // We can still use it as an OUTPUT IO pin however as the value
  // (HIGH or LOW) is not significant - it just needs to be an OUTPUT.
  // See: http://www.gammon.com.au/spi
  //
  pinMode(VS_SS, OUTPUT);

  // Now initialise the VS10xx
  digitalWrite(VS_XCS, HIGH);  //Deselect Control
  digitalWrite(VS_XDCS, HIGH); //Deselect Data
  digitalWrite(VS_RESET, LOW); //Put VS1053 into hardware reset

  // And then bring up SPI
  SPI.begin();
  SPI.setBitOrder(MSBFIRST);
  SPI.setDataMode(SPI_MODE0);

  //From page 12 of datasheet, max SCI reads are CLKI/7. Input clock is 12.288MHz.
  //Internal clock multiplier is 1.0x after power up.
  //Therefore, max SPI speed is 1.75MHz. We will use 1MHz to be safe.
  SPI.setClockDivider(SPI_CLOCK_DIV16); //Set SPI bus speed to 1MHz (16MHz / 16 = 1MHz)
  SPI.transfer(0xFF); //Throw a dummy byte at the bus
  /*
    if (testComm("Slow SPI,Testing read/write registers...")) {
        //softReset();
        result = true;
        // Switch on the anaVS1053_LOGD parts
        writeRegister(SCI_AUDATA, 44101); // 44.1kHz stereo
        // The next clocksetting allows SPI clocking at 5 MHz, 4 MHz is safe then.
        writeRegister(SCI_CLOCKF, 6 << 12); // Normal clock settings multiplyer 3.0 = 12.2 MHz
        // SPI Clock to 4 MHz. Now you can set high speed SPI clock.
        p_spi->set_speed(4000000);
        writeRegister(SCI_MODE, _BV(SM_SDINEW) | _BV(SM_LINE1));
        testComm("Fast SPI, Testing read/write registers again...");
        delay(10);
        await_data_request();
        endFillByte = wram_read(0x1E06) & 0xFF;
        //VS1053_LOGD("endFillByte is %X", endFillByte);
        //printDetails("After last clocksetting") ;
        Serial.println (endFillByte);
        delay(100);
  */
  delayMicroseconds(1);
  digitalWrite(VS_RESET, HIGH); //Bring up VS1053

  // Dummy read to ensure VS SPI bus in a known state
  VSReadRegister(SCI_MODE);

  // Perform software reset and initialise VS mode
  VSWriteRegister16(SCI_MODE, SM_SDINEW | SM_RESET);

  ///From 1053Driver
  delay(10);
  while (!digitalRead(VS_DREQ)) ; 

  VSWriteRegister16(SCI_AUDATA, 16384);
  // The next clocksetting allows SPI clocking at 5 MHz, 4 MHz is safe then.
  VSWriteRegister16(SCI_CLOCKF, 6 << 12);
  SPI.setClockDivider(SPI_CLOCK_DIV4);

  VSWriteRegister16(SCI_MODE, _BV(SM_SDINEW) | _BV( SM_STREAM ));
  //VSWriteRegister16(SCI_MODE, _BV(SM_SDINEW) | _BV( SM_RESET ));
  delay(10);
  while (!digitalRead(VS_DREQ)) ;

  VSWriteRegister16(SCI_CLOCKF,0xB800); 
  /// END
  /*
  write_register(SCI_MODE, _BV(SM_SDINEW) | _BV(SM_RESET));
  delay(1);
  await_data_request();
  write_register(SCI_CLOCKF,0xB800); // Experimenting with higher clock settings
  delay(1);
  await_data_request();
*/
  delay(200);
  //VSStatus();
#ifdef TEST

#ifdef SINTEST
  // Output a test sine wave to check everything is working ok
  //VSSineTest();
  delay(100);
  //VSStatus();
#endif // SINTEST
#endif // TEST

  // Enable real-time MIDI mode
  //VSLoadUserCode();
  //VSStatus();

  // Set the default volume
  VSWriteRegister(SCI_VOL, 0x00, 0x00);  // 0 = Maximum; 0xFEFE = silence
  VSStatus();

}

// This will read key status and mode registers from the VS10xx device
// and dump them to the serial port.
//
void VSStatus (void) {
  driverReady = 1;
#ifdef TEST
  // Print out some of the VS10xx registers
  uint16_t vsreg = VSReadRegister(SCI_MODE); // MODE Mode Register
  sprintf(teststr, "Mode=0x%04x b", vsreg);
  Serial.print(teststr);
  Serial.println(vsreg, BIN);
  vsreg = VSReadRegister(SCI_STATUS);
  sprintf(teststr, "Stat=0x%04x b", vsreg);
  Serial.print(teststr);
  Serial.print(vsreg, BIN);
  switch (vsreg & SS_VER_MASK) {
    case SS_VER_VS1003: Serial.println(" (VS1003)"); break;
    case SS_VER_VS1053: Serial.println(" (VS1053)"); break;
    default: Serial.println(" (Unknown)"); break;
  }
  vsreg = VSReadRegister(SCI_VOL); // VOL Volume
  sprintf(teststr, "Vol =0x%04x\n", vsreg);
  Serial.print(teststr);
  vsreg = VSReadRegister(SCI_AUDATA); // AUDATA Misc Audio data
  sprintf(teststr, "AUDA=0x%04x (%uHz)\n", vsreg, (vsreg & 0xFFFE));
  Serial.print(teststr);
  Serial.println();
#endif
}

// This sends a special sequence of bytes to the device to
// get it to output a test sine wave.
//
// See the datasheets for details.
//
void VSSineTest () {
  VSWriteRegister16(SCI_MODE, SM_SDINEW | SM_RESET | SM_TESTS);
  delay(100);
  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating IC is available
  digitalWrite(VS_XDCS, LOW); //Select control

  //Special 8-byte sequence to trigger a sine test
  SPI.transfer(0x53);
  SPI.transfer(0xef);
  SPI.transfer(0x6e);
  SPI.transfer(0x63);  // FIdx(7:5)=b011; S(4:0)=b00011 ==> F= ~517Hz
  SPI.transfer(0);
  SPI.transfer(0);
  SPI.transfer(0);
  SPI.transfer(0);
  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating command is complete
  digitalWrite(VS_XDCS, HIGH); //Deselect Control

  delay (2000);

  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating IC is available
  digitalWrite(VS_XDCS, LOW); //Select control

  //Special 8-byte sequence to disable the sine test
  SPI.transfer(0x45);
  SPI.transfer(0x78);
  SPI.transfer(0x69);
  SPI.transfer(0x74);
  SPI.transfer(0);
  SPI.transfer(0);
  SPI.transfer(0);
  SPI.transfer(0);
  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating command is complete
  digitalWrite(VS_XDCS, HIGH); //Deselect Control

  delay(100);
  VSWriteRegister16(SCI_MODE, SM_SDINEW | SM_RESET);
  delay(200);
}

// Write to VS10xx register
// SCI: Data transfers are always 16bit. When a new SCI operation comes in
// DREQ goes low. We then have to wait for DREQ to go high again.
// XCS should be low for the full duration of operation.
//
void VSWriteRegister(unsigned char addressbyte, unsigned char highbyte, unsigned char lowbyte) {
  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating IC is available
  digitalWrite(VS_XCS, LOW); //Select control

  //SCI consists of instruction byte, address byte, and 16-bit data word.
  SPI.transfer(0x02); //Write instruction
  SPI.transfer(addressbyte);
  SPI.transfer(highbyte);
  SPI.transfer(lowbyte);
  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating command is complete
  digitalWrite(VS_XCS, HIGH); //Deselect Control
}

// 16-bit interface to the above function.
//
void VSWriteRegister16 (unsigned char addressbyte, uint16_t value) {
  VSWriteRegister (addressbyte, value >> 8, value & 0xFF);
}

// Read a VS10xx register using the SCI (SPI command) bus.
//
uint16_t VSReadRegister(unsigned char addressbyte) {
  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating IC is available
  digitalWrite(VS_XCS, LOW); //Select control

  SPI.transfer(0x03); //Read instruction
  SPI.transfer(addressbyte);
  delayMicroseconds(10);
  uint8_t d1 = SPI.transfer(0x00);
  uint8_t d2 = SPI.transfer(0x00);
  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating command is complete
  digitalWrite(VS_XCS, HIGH); //Deselect control

  return ((d1 << 8) | d2);
}


int vs1053_chunk_size = 32;

void send_buffer(uint8_t *data, size_t len) {
  size_t chunk_length;
  while (!digitalRead(VS_DREQ)) {}
  digitalWrite(VS_XDCS, LOW);
  
  while (len) {
        //await_data_request(); // Wait for space available
        chunk_length = len;
        if (len > vs1053_chunk_size) {
            chunk_length = vs1053_chunk_size;
        }
        len -= chunk_length;
        SPI.transfer(data, chunk_length);
        data += chunk_length;
                             //
    }


  digitalWrite(VS_XDCS, HIGH);
  
}

/* from VS1053 driver */
void writeAudio(uint8_t*data, size_t len) {
  sdi_send_buffer(data, len);
}




void sdi_send_buffer(uint8_t *data, size_t len) {
    size_t chunk_length; // Length of chunk 32 byte or shorter
    data_mode_on();
    Serial.println ('writing');
    while (len) // More to do?
    {
        await_data_request(); // Wait for space available
        chunk_length = len;
        if (len > vs1053_chunk_size) {
            chunk_length = vs1053_chunk_size;
        }
        len -= chunk_length;
        SPI.transfer(data, chunk_length);
        data += chunk_length;
                             //
    }
    data_mode_off();
  } 
/*
void sdi_send_buffer(uint8_t* data, size_t len)
{

  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating IC is available
  Serial.print("VS ready");
  digitalWrite(VS_XDCS, LOW); //Select control

  while ( len )
  {
    await_data_request();
    delayMicroseconds(3);

    size_t chunk_length = min(len, 32);
    len -= chunk_length;
    while ( chunk_length-- )
      SPI.transfer(*data++);
  }
  while (!digitalRead(VS_DREQ)) ; //Wait for DREQ to go high indicating command is complete
  Serial.print("VS off");
  digitalWrite(VS_XDCS, HIGH); //Deselect Control
}
*/

void streamModeOn() {
    //VS1053_LOGI("Performing streamModeOn");
    VSWriteRegister16(SCI_MODE, _BV(SM_SDINEW) | _BV(SM_STREAM));
    delay(10);
    await_data_request();
}

void streamModeOff() {
    //VS1053_LOGI("Performing streamModeOff");
    VSWriteRegister16(SCI_MODE, _BV(SM_SDINEW));
    delay(10);
    await_data_request();
}

void write_bytes(uint8_t * data, uint32_t size)   {
  SPI.transfer(data, size);
  // for (int i = 0; i < size; ++i) {
  //     p_spi->transfer(data[i]);
  // }
}

void await_data_request(void)
{
  while ( !digitalRead(VS_DREQ) );
}


void control_mode_on(void)
{
  digitalWrite(VS_XDCS, HIGH);
  digitalWrite(VS_XCS, LOW);
}

void control_mode_off(void)
{
  digitalWrite(VS_XCS, HIGH);
}

void data_mode_on(void)
{
  digitalWrite(VS_XCS, HIGH);
  digitalWrite(VS_XDCS, LOW);
}

void data_mode_off(void)
{
  digitalWrite(VS_XDCS, HIGH);
}



/*
  pinMode(VS_DREQ, INPUT);
  pinMode(VS_XCS, OUTPUT);
  pinMode(VS_XDCS, OUTPUT);
  pinMode(VS_RESET, OUTPUT);
*/
/* from VS1003 driver */
/*
  // VS1003 SCI Write Command byte is 0x02
  #define VS_WRITE_COMMAND 0x02

  void await_data_request(void)
  {
    while ( !digitalRead(VS_DREQ) );
  }

  void control_mode_on(void)
  {
    digitalWrite(VS_XDCS,HIGH);
    digitalWrite(VS_XCS,LOW);
  }

  void control_mode_off(void)
  {
    digitalWrite(VS_XCS,HIGH);
  }

  void data_mode_on(void)
  {
    digitalWrite(VS_XCS,HIGH);
    digitalWrite(VS_XDCS,LOW);
  }

  void data_mode_off(void)
  {
    digitalWrite(VS_XDCS,HIGH);
  }

  void write_register(uint8_t _reg,uint16_t _value)
  {
  control_mode_on();
  delayMicroseconds(1); // tXCSS
  SPI.transfer(VS_WRITE_COMMAND); // Write operation
  SPI.transfer(_reg); // Which register
  SPI.transfer(_value >> 8); // Send hi byte
  SPI.transfer(_value & 0xff); // Send lo byte
  delayMicroseconds(1); // tXCSH
  await_data_request();
  control_mode_off();
  }

  void playChunk(const uint8_t* data, size_t len)
  {
  //spi_saver_t spi_saver;
  //set_our_spi();
  sdi_send_buffer(data,len);
  }


  void sdi_send_buffer(const uint8_t* data, size_t len)
  {
  data_mode_on();
  while ( len )
  {
    await_data_request();
    delayMicroseconds(3);

    size_t chunk_length = min(len,vs1003_chunk_size);
    len -= chunk_length;
    while ( chunk_length-- )
      SPI.transfer(*data++);
  }
  data_mode_off();
  }



  void sdi_send_zeroes(size_t len)
  {
  data_mode_on();
  while ( len )
  {
    await_data_request();

    size_t chunk_length = min(len,vs1003_chunk_size);
    len -= chunk_length;
    while ( chunk_length-- )
      SPI.transfer(0);
  }
  data_mode_off();
  }*/
